//Creating the Recent Item classmodel.RecentItem = new DataClass("RecentItems");//Add Recent Item attributes.model.RecentItem.ID = new Attribute("storage", "long", "key auto");model.RecentItem.dataClassName = new Attribute("storage", "string", "btree");model.RecentItem.entityKey = new Attribute("storage", "long", "btree");model.RecentItem.sortOrder = new Attribute("storage", "long", "btree");model.RecentItem.title = new Attribute("storage", "string", "btree");model.RecentItem.converted = new Attribute("storage", "bool", "cluster");model.RecentItem.owner = new Attribute("relatedEntity", "User", "User"); // relation to the User class//Class methods.model.RecentItem.methods = {};model.RecentItem.methods.newRecentItem = function(dataClassName, titleKey, titleValue, entityKey) {	//Create a new Recent Item if it does not exist yet and update the Recent Items and return them.	var dupCollection, dupCollectionLength,		myCurrentUser, myUser,		recentItemArr = [];	//Get the current user session and load their User entity.	myCurrentUser = currentUser(); // we get the user of the current session.	myUser = ds.User.find("ID = :1", myCurrentUser.ID);		if (myUser != null) {		//Check if this recent item already exists. If so, no need to add it.		dupCollection = ds.RecentItem.all();		dupCollectionLength = dupCollection.length		dupItem = ds.RecentItem.find("entityKey = :1 && owner.ID = :2", entityKey, myUser.ID);		if (dupItem != null) {				if (dupItem.sortOrder != 1) { 				renumberRecentItems = ds.RecentItem.query("sortOrder < :1", dupItem.sortOrder);				renumberRecentItems.forEach(function(recentItemEntity) {					recentItemEntity.sortOrder += 1;				});								dupItem.sortOrder = 1;				dupItem.save();			}		} else {		//Not a duplicate, so create new Recent Item.			try {				new ds.RecentItem({					dataClassName: dataClassName,					title: titleKey + titleValue,					entityKey: entityKey,					sortOrder: 0				}).save();				//Now reorder the recent items.				ds.RecentItem.reorderItems();			}			catch(e) {			}			} //if (dupItem != null)			var recentItemsCollection = ds.RecentItem.query("ID > 0 order by sortOrder asc");		recentItemArr = recentItemsCollection.toArray("dataClassName, entityKey, title, sortOrder");	} //if (myUser != null)		return recentItemArr;}; //end - newRecentItem()//Class methods scope.model.RecentItem.methods.newRecentItem.scope = "public";//Eventsmodel.RecentItem.events = {};//onInit()model.RecentItem.events.onInit = function() {	var myCurrentUser = currentUser(), // we get the user of the current session.		myUser = ds.User.find("ID = :1", myCurrentUser.ID);			if ((myCurrentUser !== null) && (myUser !== null)) {//if a user is logged in.				this.owner = myUser;	}		this.converted = false;}; //end - onInit().//onRestrictingQuery()model.RecentItem.events.onRestrictingQuery = function() {	var myCurrentUser = currentUser(), // we get the user of the current session.		sessionRef = currentSession(), // Get session.		result;			result = ds.RecentItem.createEntityCollection(); //default to empty collection.		if (sessionRef.belongsTo("Administrator")) {		result = ds.RecentItem.all();	} else {		result = ds.RecentItem.query("owner.ID = :1", myCurrentUser.ID);	}		return result;}; //end - onRestrictingQuery().